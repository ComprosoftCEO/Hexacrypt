# Hexacrypt
Simple text-based encryption algorithm

<br>

## Features of Hexacrypt

1. Requires a "Secret Key" to encode and decode messages.

2. All input and output is done in text characters, so there is no need to worry about hexadecimal bytes.

3. The same input and key can produce completely different outputs of different lengths. Look at some of the outputs for the message "Hello!"
   * |P6]Cj\\j\'E!P-Gs
   * ZNDH36[sRjFK"x]+~
   * i2Bf\`q{i "XnT\\^9

<br>

## Weaknesses

1. Uses seed with insecure pseudo-random number generator to shuffle string

2. Flaws in algorithm design make it insecure for serious data encryption.

<br>

## Custom Objects Used

* __Hash8__ - Implementation of [Pearson Hashing](https://en.wikipedia.org/wiki/Pearson_hashing) that accepts a string as input
* __Rand64__ - Custom Pseudo-Random number generator. Uses a [Linear Congruential Generator](https://en.wikipedia.org/wiki/Linear_congruential_generator) to fill an array of 32 elements, then iterates over the array to generate numbers. Rand64 is used for all random generation in the algorithm.
 <br>

## The Algorithm

### Step 1: Filter
This is a simple enough step. The computer removes any “illegal characters”, such as emoji’s, special letters, etc. from the message and secret key. Any of these characters would mess up the encryption process.
<br>
<br>

### Step 2: Get Seed
Using the secret key provided, the computer runs the string through a simple hashing algorithm called Hash8. The algorithm returns a 64-Bit unsigned integer that is used to seed a Rand64 object.
<br>
<br>

### Step 3: Shuffle Characters
This step involves a string that has all characters that can be used in the message:

* \!\"\#\$\%\&\'\(\)\*\+\,\-\./0123456789:;\<=\>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]\^\_\`abcdefghijklmnopqrstuvwxyz\{\|\}\~

<br>

Using the random number and seed from _Step 2_, this string is shuffled up to resemble something like this:

*  c1\(\#\$m8eTb\"KjDpH\-\.\'\+u\&\;Vx6\|sw\*Z\~\!\<LrkS4tEoQ\=fz\[iGM\`\>vN\/O\\3lhA\]WXCFa0BP9Y\{2J\,d\:\)7\@ \_UIR\%n5\}\^qy\?g

To shuffle the string, the computer picks a random character from the original string and adds it to the front of new string.
This character is removed from the original string, and the process continues until there are no characters left.

<br>

### Step 4: Pseudo Xor
In this step, characters in the secret message are replaced using characters in the shuffled up string. The first character is replaced with the last character, the second character is replaced with the second to last character, and so on. While this method works for easy encryption and decryption, the downside is that no letter will ever be replaced by itself. This step is called “Pseudo Xor” because it mimics the binary xor operator where binary digits flipped, just as the letters are flipped across the string. When decrypting the message, Pseudo Xor will return the starting letter, making it ideal for this algorithm.

<br>

### Step 5: Really Mix Things Up
To make the algorithm more secure, _Steps 3 - 4_ are repeated for every single character in the secret message. That means that the string in _Step 3_ is being reshuffled over and over into different strings for __every character__ in the secret message before being passed to the Pseudo Xor. As a result, the same character can be mapped to many different characters while encrypting the secret message, similar to the Nazi [Enigma Machine](https://en.wikipedia.org/wiki/Enigma_machine).

<br>

### Step 6: Reverse String
To make the encryption algorithm more secure, the string is reversed before going on to the next step.

_This is to keep step 7 from accidentally undoing the Pseudo-XOR from the above steps._

<br>

### Step 7: Add Some Garbage
After the entire string has been mixed up, 1 to 10 random “garbage” characters are added onto the front and back of the string. Since these characters can be anything and not mess up the algorithm, they are different every time the message is encrypted, meaning that the same message can be encrypted many different ways. 

After the “garbage” is added on to the string, two more characters are placed on the back of the string to indicate how much “garbage” to remove when decrypting the message. This is done using the shuffled up string from _Step 3_, which is generated by resetting the pseudo-random number generator to the original seed from _Step 2_. The index of the letter in the string indicates the number of "garbage" characters to add on.

_This step is responsible for the same message and key producing completely different outputs._

<br>

### Step 8: Checksum
Hexacrypt uses a checksum to help with decoding the string, making it easier to trap errors with invalid keys. The string from the previous step is fed into the Hash8 algorithm, and an 8-Bit checksum is generated. The checksum becomes the character index of the unshuffled string of all characters (from _step 3_), looping around if the checksum is larger than the length of the string. This single character is then appended on to the front of the string from the previous step.

<br>

### Step 9: The Final Shuffle
Once the checksum and garbage are added to the encrypted message, it it time to do one final shuffle. The seed for the pseudo-random number generator is reset once again to the value from _Step 2_. (_This is so the algorithm can be reversed and the message decrypted._) _Steps 3 - 4_ are repeated to encrypt the checksum + garbage string from the previous step. 

<br>

---

The message is now __fully encrypted!__ No one will be able to read it unless they have the secret key.<br>
(_or they are a cryptographer_).
